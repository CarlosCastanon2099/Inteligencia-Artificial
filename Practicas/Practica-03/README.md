<div align="center">

# ðŸ¤– **Practica 03** ðŸ‘»



# **Exploradores de Laberinto (DFS y BFS)**


</div>



<div align="center">

[![](https://upload.wikimedia.org/wikipedia/commons/b/bc/Maze_representation_using_wireframes_2022-01-10.gif)](https://www.youtube.com/watch?v=XPpTgCho5ZA)

</div>

----

[Bfs-Dfs.webm](https://github.com/CarlosCastanon2099/Inteligencia-Artificial/assets/108638686/76958877-af91-4e92-aa9c-7494e98280ea)


----

## **Requerimientos**

[![Python 3.11](https://img.shields.io/badge/python-3.11-blue.svg)](https://www.python.org/downloads/release/python-311/)

Para la presente implementacion se contemplaron las bibliotecas adicionales de numpy, matplotlib y de networkx, en caso de no tenerlas instaladas, ejecutar:

```C
> pip install matplotlib
```

```C
> pip install networkx
```

```C
> pip install numpy
```

Es importante recordar tambien que debemos asegurarnos de que tenemos instalado [Jupyter](https://jupyter.org/install).

```C
> pip install jupyterlab
```

```C
> pip install notebook
```


---

## **Uso**

Para correr el programa del agente inteligente que resuelve un laberinto, se debe abrir el Jupyter Notebook en algun editor (como Jupyter nativo, VS Code, etc.).

[Practica-03](./practica03.ipynb)

Una vez dentro del Notebook, podremos modificarlo para que podamos probar laberintos propios o bien probar con los laberintos aleatorios para veer como es que 
un agente inteligente resuelve el laberinto usando la tecnica de DFS, BFS y Back-Tracking, esto con el fin de tener una representacion visual sobre como es que un agente inteligente
puede resolver un laberinto usando estas tres tecnicas antes mencionadas.
